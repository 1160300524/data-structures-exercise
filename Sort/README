对于快排的优化
“四大“优化策略：
1、	三点取中的优化
2、	在小区间使用插入排序替代快速排序
3、	有相同元素时，聚中减少递归次数
4、	（伪）尾递归，本来认为此法有效果，后来实际实验后发现无论效率还是空间都没有明显的提升，原因是在快排的算法中，尾递归优化是不存在的。

对快排算法本身，如果使用最基本的固定枢轴的方法，在排序数据是高度乱序（随机度较高）的情况下，时间复杂度稳定在O(logn),但是测试时数据若是已经有序的，或是重复的数字较多，时间复杂度接近于O(n2)
所以优化针对的就是已经有序的和重复数字较多的情况。

1、	三点取中的方法：
思路：选取枢轴时，在左端点和右端点以及中间节点三个值中，选择一个中间值作为枢轴，这样可以有效避免已经有序的输入情况。
2、	插入排序的方式：
经过时间证明在排序的数量少于16时，插入排序的效率要高于其他所有的排序，所以可以使用插入排序优化速度
3、	聚中的方式
当有相同元素时，扫描区间时，遇到与枢轴相同的元素时，将元素放到区间的两端，当扫描结束后，将枢轴的位置调节为扫描标记停止的位置，然后将两边的与枢轴值相同的元素调整到枢轴的周围。在进行递归时，枢轴周围相同的元素将被跳过，不再进行递归。
这样可以避免相同元素对快排效率的影响。
4、	关于尾递归优化的认知
在查资料时看到尾递归优化的方式，于是查看了尾递归的含义：
递归函数在一个函数返回的位置，由于是函数的结束，之前函数栈帧的内容将不再进行保存，只保存当前递归函数的内容，这样无论递归多少次对不会发成stack overflow 的错误，而且可以减少对栈空间的使用。
查到快排的这样一个尾递归方式：
1.	public void QuickSort(int[] num, int low, int high)
2.	    {
3.	        int pivot;
4.	        while (low < high)
5.	        {
6.	            pivot = partition(num, low, high); ;
7.	            QuickSort(num, low, pivot - 1); // 对低子表递归排序
8.	            low = pivot + 1; // 尾递归
9.	        }
10.	    }
我自己写了一个类似的实现，多次实验后发现并没有明显的效果，我开始分析原因：
这个实现是将
1.	quickSort(list,pivot+1,high);
替换为了
11.	 low = pivot + 1; // 尾递归
并且通过循环的方式，每一次循环改变了low(左端点)，和pivot(枢点)，然后进入下一次递归。
发现这样的写法和直接进行右递归是基本一样的实现方式，首先递归的次数一次都没有减少，不存在效率上的优化。
其次，尾递归是在调用递归函数后，父函数结束，不再保存其栈帧，然而上面的循环写法明显在调用递归函数后，父函数没有结束运行，栈帧的信息依旧保存，并没有减少，所以这种优化就是没有作用，还会增加代码的复杂度，使得代码的可读性下降。快排算法不存在尾递归的优化。

线性排序的比较
三种线性排序的理解：
1、	桶排序  是设置一些区间，通过将要排序的数字通过一定的规则划分进这些区间（桶），然后使用别的方法将他们排序
2、	计数排序   是使用一个额外的空间，其中存储的是要排序数出现的次数。
3、	基数排序    是按照不同的关键词进行排序的方式
共同点：1、都是通过空间换取时间的方式实现高效率
2、	都是利用了数值的空间局部性的特点，实现高效的排序
3、	都不是通过比较数值大小，而是使用数值作为下标直接映射到某一空间或者记录出现的次数，超过了用单纯比较方式排序的下限
不同点：1、其中的桶排序在桶内的排序是随意地，所以桶排序不稳定，其效率既取决于给的数据是否能够均匀分布在这些桶内，还取决于桶内排序算法是否高效，同时还有桶的个数也其关键作用，桶的个数越多，每个桶内的排序元素数量就会减少。  桶排序可以对浮点数进行排序  桶排序一般情况下是三个排序中最慢的，但是计数排序是一种特殊的桶排序。
2、计数排序在三种排序中效率最高，但是对内存的消耗最大，对输入的数据范围也有要求 ，如果输入的数据太大，会浪费大量的空间，同时无法对浮点数进行排序，也是一大缺点
3、基数排序兼具效率空间的优良特性，在效率上，最好可以达到O(n)的效率，空间上的开销也是可以控制的，通过调节基数的大小，达到平衡空间和时间需求的目的：   基数越大，基数排序越接近于计数排序，空间开销增大，但是时间复杂性会大大降低，   基数越小，空间的开销越小，但是时间复杂性越高，因为需要排序的次数增大  ，复杂度为O(K*N),随着基数的增大，K会增大。  K是根据基数确定的最大的位数。

在三种排序中，基数排序的时间和空间相对平衡，也比较稳定，可以与快速排序相媲美。

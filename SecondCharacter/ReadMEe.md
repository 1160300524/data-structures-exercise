
# 算数表达式求值

### 目录
> [1.使用指导](#使用指导)
> [2.功能概要](#功能概要)
> [3.主要数据类型](#主要数据类型)
> [4.函数功能](#函数功能)
> [5.算法思路](#算法思路)


### 使用指导：
> 将operation.cpp用g++编译后直接运行即可

### 功能概要
> 这是一个控制台程序，根据提示，可以输入一个不限长度的算术表达式，按回车之后第一行输出一个此算术表达式对应的后缀表达式
> 
> 运行示例：
> > 请输入计算式：(输入#结束程序运行)
> >1324+5434*(433+43)/43+43%23
> > 该式子的后缀表达式如下
> > 1324 5434 433 43 + 43 / * 43 23 % + +
> > 该算术表达式的计算结果如下
> > 61497.1
> > 请输入计算式：(输入#结束程序运行)
> > ……
> >请输入计算式：(输入#结束程序运行)
> > #
> > Process finished with exit code 0

### 主要数据类型
**```bool pority[7][7]```**
>  这个二维数组用来描述算术的优先级，第一个[ ]代表先出现的运算符，第二个[ ]代表后出现的运算符，存入的**true**表示**pority[i][j]**中**i**的优先级高于**j**

**```union charOrDouble```**
>  由于在处理后缀表达式时栈内有时需要存储浮点数，有时需要存储字符串，定义一个联合体可以使它们共用存储

**```struct cellElement```**
>  由于栈是用指针实现，需要封装一个节点元素，包含了一个**cellElement**类型的指针，指向下一节点，一个**charOrDouble** 用于保存该节点的数据，一个**bool** 的数据，用于标记联合体中存储的是浮点型还是字符，*ture* 表示是浮点型，*false* 表示是存的是字符

**```class stack```**
>  这个类包含了数据类型栈的长度，和各种动作
>  1.入栈操作**void push(charOrDouble ，bool)**
> 2.出栈操作**charOrDouble pop()** 从栈中删除最后一个入栈的元素，并返回该元素存储的数据
> 3.**charOrDouble top()** 只返回栈顶的元素存储的数据，与*pop()* 操作的不同在于*top()* 不删除栈顶的元素
>  4.**void Empty()** 判断栈是否为空，如果空，返回*true* 不空返回 *false*
>  5.**length** 一直指示栈的元素个数

**```class mid2tail:stack```**
>  该栈用于存储后缀表达式中的运算符，与**stack** 不同的是，这个类包含了max的一个stack类型的栈，这个栈的栈顶一直保存着优先级最高的字符串，为中缀表达式转后缀表达式做准备。 

**```string Input```**
>  存储从控制台输入的字符串

### 函数功能
bool CheckInput()
> 此函数将输入的字符串遍历一遍，遇到 ' ( ' 入栈，遇到 ' ) '出栈，当字符串遍历结束，如果栈内还有 ‘ （ ' 未出栈，则表明算术表达式输入 不合法，如果字符串还未遍历完，栈已经为空，不能再出栈时，表明字符串输入也不合法。

void mid2post()
>  这个函数将输入的输入的算术表达式转化为中缀表达式

bool mid2result()
>  这个函数将后缀表达式计算出结果，并输出
>   返回值true 表示计算过程无误，可以输出结果，返回值false表示算术表达式输入不合法或遇到一场情况需要重新输入。

void OneTime()
>   这个函数是对一次输入算术表达式转化求值的封装，使主程序简介

### 算法思路
先将输入的中缀表达式转化为后缀表达式，转化的思路是从头遍历字符串，遇到数字直接输出，遇到操作符，如果它比栈中已有的操作符的优先级都大，就入栈，否则将栈内的操作符依次出栈，直到满足入栈的条件。
计算后缀表达式的思路是：遍历后缀表达式，遇到数字入栈，遇到操作符从栈内弹出两个数字，计算出结果后再入栈。最后栈内剩余的数字就是最终的结果。

### 流程图

```flow
st=>start: 程序开始
e=>end
io=>inputoutput: 输入表达式
op1=>operation: 中缀表达式转后缀表达式
sub1=>subroutine: 由后缀表达式计算
cond1=>condition: 输入格式是否正确?
cond2=>condition: 计算过程是否出错？
cond3=>condition: 输入是否是结束标识符 '#' 

st->io->cond3
cond3(yes)->e
cond3(no)->cond1
cond1(no)->io
cond1(yes)->op1->sub1->cond2
cond2(no)->e
cond2(yes)->io



```